import java.util.Collections;
import java.util.InputMismatchException;
import java.math.BigInteger;
import java.util.Collection;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.List;
import java.util.Comparator;
import java.io.*;
import java.util.Iterator;
import java.util.Arrays;
import java.util.Queue;

/**
 * Generated by Contest helper plug-in
 * Actual solution is at the bottom
 */
public class Main {
	public static void main(String[] args) {
		try {
			System.setIn(new FileInputStream("input.in"));
			System.setOut(new PrintStream(new FileOutputStream("b.out")));
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
		InputReader in = new StreamInputReader(System.in);
		PrintWriter out = new PrintWriter(System.out);
		run(in, out);
	}

	public static void run(InputReader in, PrintWriter out) {
		Solver solver = new B();
		int testCount = in.readInt();
		for (int i = 1; i <= testCount; i++)
			solver.solve(i, in, out);
		Exit.exit(in, out);
	}
}

abstract class InputReader {
	private boolean finished = false;

	public abstract int read();

	public int readInt() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		int res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public long readLong() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		long res = 0;
		do {
			if (c < '0' || c > '9')
				throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isSpaceChar(c));
		return res * sgn;
	}

	public String readString() {
		int c = read();
		while (isSpaceChar(c))
			c = read();
		StringBuffer res = new StringBuffer();
		do {
			res.appendCodePoint(c);
			c = read();
		} while (!isSpaceChar(c));
		return res.toString();
	}

	private boolean isSpaceChar(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}

	public void setFinished(boolean finished) {
		this.finished = finished;
	}

	public abstract void close();
}

class StreamInputReader extends InputReader {
	private InputStream stream;
	private byte[] buf = new byte[1024];
	private int curChar, numChars;

	public StreamInputReader(InputStream stream) {
		this.stream = stream;
	}

	public int read() {
		if (numChars == -1)
			throw new InputMismatchException();
		if (curChar >= numChars) {
			curChar = 0;
			try {
				numChars = stream.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (numChars <= 0)
				return -1;
		}
		return buf[curChar++];
	}

	public void close() {
		try {
			stream.close();
		} catch (IOException ignored) {
		}
	}
}

class Exit {
	private Exit() {
	}

	public static void exit(InputReader in, PrintWriter out) {
		in.setFinished(true);
		in.close();
		out.close();
	}
}

interface Solver {
	public void solve(int testNumber, InputReader in, PrintWriter out);
}

class Pair<U, V> implements Comparable<Pair<U, V>> {
	public final U first;
	public final V second;

	public static<U, V> Pair<U, V> makePair(U first, V second) {
		return new Pair<U, V>(first, second);
	}

	private Pair(U first, V second) {
		this.first = first;
		this.second = second;
	}

	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;

		Pair pair = (Pair) o;

		return !(first != null ? !first.equals(pair.first) : pair.first != null) && !(second != null ? !second.equals(pair.second) : pair.second != null);

	}

	public int hashCode() {
		int result = first != null ? first.hashCode() : 0;
		result = 31 * result + (second != null ? second.hashCode() : 0);
		return result;
	}

	public String toString() {
		return "(" + first + "," + second + ")";
	}

	public int compareTo(Pair<U, V> o) {
		int value = ((Comparable<U>)first).compareTo(o.first);
		if (value != 0)
			return value;
		return ((Comparable<V>)second).compareTo(o.second);
	}
}

class IOUtils {

	public static long[] readLongArray(InputReader in, int size) {
		long[] array = new long[size];
		for (int i = 0; i < size; i++)
			array[i] = in.readLong();
		return array;
	}

	public static long[][] readLongTable(InputReader in, int rowCount, int columnCount) {
		long[][] table = new long[rowCount][];
		for (int i = 0; i < rowCount; i++)
			table[i] = readLongArray(in, columnCount);
		return table;
	}

	}

class MiscUtils {
	public static final int[] DX4 = {1, 0, -1, 0};
	public static final int[] DY4 = {0, -1, 0, 1};

	}

class IntegerUtils {

	public static int longCompare(long a, long b) {
		if (a < b)
			return -1;
		if (a > b)
			return 1;
		return 0;
	}

	}

class B implements Solver {
	public void solve(int testNumber, InputReader in, PrintWriter out) {
		System.err.println(testNumber);
		int rowCount = in.readInt();
		int columnCount = in.readInt();
		int maxErosion = in.readInt();
		long[][] map = IOUtils.readLongTable(in, rowCount, columnCount);
		long answer = 0;
		while (isNotEnd(rowCount, columnCount, map)) {
			long[][] erosion = erosionPerTurn(rowCount, columnCount, maxErosion, map);
			long steps;
			for (int i = 0; ; i++) {
				long[][] pseudoMap = new long[rowCount][columnCount];
				boolean bad = false;
				for (int j = 0; j < rowCount; j++) {
					for (int k = 0; k < columnCount; k++) {
						pseudoMap[j][k] = map[j][k] - erosion[j][k] * (1 << i);
						if (pseudoMap[j][k] < 0)
							bad = true;
					}
				}
				if (!bad) {
					long[][] pseudoErosion = erosionPerTurn(rowCount, columnCount, maxErosion, pseudoMap);
					for (int j = 0; j < rowCount; j++) {
						for (int k = 0; k < columnCount; k++) {
							if (pseudoErosion[j][k] != erosion[j][k])
								bad = true;
						}
					}
				}
				if (bad) {
					steps = 1 << i;
					break;
				}
			}
			steps /= 2;
			if (steps == 0)
				steps = 1;
			answer += steps;
			long[][] water = countWaterLevels(rowCount, columnCount, map);
			for (int j = 0; j < rowCount; j++) {
				for (int k = 0; k < columnCount; k++) {
					map[j][k] = map[j][k] - erosion[j][k] * steps;
					if (map[j][k] < 0)
						throw new RuntimeException();
				}
			}
		}
		out.println("Case #" + testNumber + ": " + answer);
	}

	private long[][] erosionPerTurn(int rowCount, int columnCount, int maxErosion, long[][] map) {
		long[][] waterLevels = countWaterLevels(rowCount, columnCount, map);
		long[][] erosion = new long[rowCount][columnCount];
		for (int i = 0; i < rowCount; i++) {
			for (int j = 0; j < columnCount; j++) {
				long minLevel = minLevel(rowCount, columnCount, waterLevels, i, j);
				erosion[i][j] = Math.min(waterLevels[i][j] - minLevel, maxErosion);
			}
		}
		return erosion;
	}

	private long minLevel(int rowCount, int columnCount, long[][] waterLevels, int i, int j) {
		long minLevel = Long.MAX_VALUE;
		for (int k = 0; k < 4; k++) {
			int row = i + MiscUtils.DX4[k];
			int column = j + MiscUtils.DY4[k];
			if (row >= 0 && row < rowCount && column >= 0 && column < columnCount)
				minLevel = Math.min(minLevel, waterLevels[row][column]);
			else
				minLevel = 0;
		}
		return minLevel;
	}

	private long[][] countWaterLevels(int rowCount, int columnCount, final long[][] map) {
		final long[][] waterLevel = new long[rowCount][columnCount];
		for (int i = 0; i < rowCount; i++) {
			for (int j = 0; j < columnCount; j++) {
				Queue<Pair<Integer, Integer>> queue = new PriorityQueue<Pair<Integer, Integer>>(rowCount * columnCount, new Comparator<Pair<Integer, Integer>>() {
					public int compare(Pair<Integer, Integer> o1, Pair<Integer, Integer> o2) {
						return IntegerUtils.longCompare(map[o1.first][o1.second], map[o2.first][o2.second]);
					}
				});
				queue.add(Pair.makePair(i, j));
				boolean[][] visited = new boolean[rowCount][columnCount];
				visited[i][j] = true;
				long result = 0;
				while (!queue.isEmpty()) {
					int row = queue.peek().first;
					int column = queue.poll().second;
					result = Math.max(result, map[row][column]);
					if (row == 0 || column == 0 || row == rowCount - 1 || column == columnCount - 1)
						break;
					for (int k = 0; k < 4; k++) {
						int newRow = row + MiscUtils.DX4[k];
						int newColumn = column + MiscUtils.DY4[k];
						if (!visited[newRow][newColumn]) {
							queue.add(Pair.makePair(newRow, newColumn));
							visited[newRow][newColumn] = true;
						}
					}
				}
				waterLevel[i][j] = result;
			}
		}
		return waterLevel;
	}

	private boolean isNotEnd(int rowCount, int columnCount, long[][] map) {
		boolean nonZero = false;
		for (int i = 0; i < rowCount; i++) {
			for (int j = 0; j < columnCount; j++) {
				if (map[i][j] != 0)
					nonZero = true;
			}
		}
		return nonZero;
	}
}

