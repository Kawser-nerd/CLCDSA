/*
???  ??????
?? ?´????)?????/???????????????????
?? ??y:::::???? [?]??????????????????????????????????
?? |:?:|:::::|???|??|
?????????????????|?????????????????
???????????????|??  ??????????????????????????????
???????????????|
???????????????.?|????????????????????????????????
????????????? ??  |??????????????????????????
??????????|???  |?????????????????????????????????
?????????????? |????????????????????
???(??)?(??)?(??)??|
?    ||?? ||??||??|??? ????????????
??.?|???|? ?|?
*/

#include <iostream>
#include <cstdlib>
#include <algorithm>
#include <array>
#include <bitset>
#include <climits>
#include <cmath>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <string>
#include <vector>
using namespace std;
#define fst first
#define snd second
#define ALL(obj) (obj).begin(),(obj).end()
#define debug(x) cerr << #x << " -> " << x << " (line:" << __LINE__ << ")" << '\n';
#define debugpair(x, y) cerr << "(" << #x << ", " << #y << ") -> (" << x << ", " << y << ") (line:" << __LINE__ << ")" << '\n';
typedef long long lint;
typedef priority_queue<int> p_que;
typedef priority_queue<int, vector<int>, greater<int>()> p_que_rev;
const int INF = INT_MAX;
const lint LINF = LLONG_MAX;
const int MOD = 1000000000 + 7;
const double EPS = 1e-9;
const double PI = acos(-1);
const int di[]{0, -1, 0, 1, -1, -1, 1, 1};
const int dj[]{1, 0, -1, 0, 1, -1, -1, 1};

// Graph Templates
using Weight = lint;
using Flow = lint;
struct Edge {
    int src, dst;
    Weight weight;
    Flow cap;
    Edge() : src(0), dst(0), weight(0) {}
    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}
};
using Edges = vector<Edge>;
using Graph = vector<Edges>;
using Array = vector<Weight>;
using Matrix = vector<Array>;
const Weight inf = numeric_limits<Weight>::max() / 8;

struct ford_fulkerson {
    using Matrix = vector<vector<Flow>>;
    int n, t;
    vector<int> vis;
    vector<vector<Flow>> cap, flow;
    vector<vector<int>> g;
    const Flow INF;
    ford_fulkerson(int n)
        : n(n),
        cap(n, vector<Flow>(n)),
        flow(n, vector<Flow>(n)),
        g(n, vector<int>()),
        INF(numeric_limits<Flow>::max() / 8) {}
    ford_fulkerson(const Graph &graph) : ford_fulkerson(graph.size()) {
        for (int i = 0; i < n; ++i)
            for (auto &e : graph[i]) add_edge(e.src, e.dst, e.cap);
    }
    void add_edge(int u, int v, Flow c) {
        cap[u][v] += c;
        cap[v][u] += c;
        flow[v][u] += c;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    Flow solve(int s, int t) {
        this->t = t;
        Flow res = 0, aug = 1;
        while (aug > 0) {
            vis.assign(n, false);
            res += (aug = augment(s, INF));
        }
        return res;
    }
    Flow augment(const int &v, const Flow &lim) {
        vis[v] = true;
        if (v == t) return lim;
        for (const int &d : g[v]) {
            if (vis[d] || flow[v][d] == cap[v][d]) continue;
            Flow aug = augment(d, std::min(lim, cap[v][d] - flow[v][d]));
            flow[v][d] += aug;
            flow[d][v] -= aug;
            if (aug > 0) return aug;
        }
        return 0;
    }
};

int main(){
    int n, mark, e;
    cin >> n >> mark >> e;
    int a, b;
    Graph g;
    g.resize(n+1);
    ford_fulkerson ff(g);
    vector<int> p(mark);
    for (int i=0; i<mark; ++i){
        cin >> p[i];
        ff.add_edge(p[i], n, 1);
        ff.add_edge(n, p[i], 1);
    }
    for (int i=0; i<e; ++i){
        cin >> a >> b;
        ff.add_edge(a, b, 1);
        ff.add_edge(b, a, 1);
    }
    Flow ans = ff.solve(0, n);
    cout << ans << endl;
    return 0;
}