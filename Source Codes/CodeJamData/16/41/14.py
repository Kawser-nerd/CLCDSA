"""
select alphabetically earliest lineup that has property that the contest will not stall, given number of R P S players

for all the same strategy there's no way to make it happen

for one round, only works if two players' strategies are different
for two rounds, only works if individual rounds work and they have different outcomes

none of R P S can be more than half of the entrants
is that a sufficient condition recursively? no, consider RRPP

P > R
R > S
S > P

limit: N <= 12, which means 2^12 = 4096 entrants

could try simple dynamic programming...

is outcome unique given entrants?
RPRS -> PS

we could look at set of valid tournaments as generated by replacement rule:
R -> RS
S -> SP
P -> RP

this is deterministic and constrains the set of valid tournaments

nr_i = nr_{i - 1} + np_{i - 1}

R   P   S
1   0   0 R
1   1   0 RS
1   2   1 RSSP
2   3   3 RSSPSPRP
5   5   6
...

ok, so we can use this rule to get number of players in each side of tournament?
"""

players = {
    'R': 'RS',
    'S': 'SP',
    'P': 'RP'
}

memo = {}
def gen_tourney(n, winner):
    if (n, winner) in memo:
        return memo[n, winner]
    if n == 0:
        result = winner
    else:
        t1 = gen_tourney(n - 1, players[winner][0])
        t2 = gen_tourney(n - 1, players[winner][1])
        if t1 < t2:
            result = t1 + t2
        else:
            result = t2 + t1
    memo[n, winner] = result
    return result

from collections import Counter
def solve(n, r, p, s):
    desired_hist = Counter({'R': r, 'P': p, 'S': s})
    for winner in 'RPS':
        t = gen_tourney(n, winner)
        hist = Counter(t)
        if all(hist[c] == desired_hist[c] for c in 'RPS'):
            return t
    return 'IMPOSSIBLE'

if __name__ == '__main__':
    import sys
    fp = open(sys.argv[1])
    def readline():
        return fp.readline().strip()
    num_cases = int(readline())
    for i in xrange(num_cases):
        n, r, p, s = [int(x) for x in readline().split()]
        print "Case #%d: %s" % (i + 1, solve(n, r, p, s))
