#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# ??PDF?????
#
# ??????????2????????????????????????
#
# ???????????????????? 
# 1??????3???????????????????????????
#
# ?????????????????????????????????????
# ???????
#
# ???????????????????????????????
# ????????????????????????
# ?????????????
#
# ????????????????PDF?????
# ??4????2?????????????????
# ??Python??????????????1000?????

import array
from bisect import *
from collections import *
import fractions
import heapq
from itertools import *
import math
import random
import re
import string
import sys

sys.setrecursionlimit(1000000)

N, M = map(int, input().split())

edges = defaultdict(list)
edge_num = Counter()
for m in range(M):
    a, b = map(int, input().split())
    edge_num[a] += 1
    edge_num[b] += 1
    edges[a].append(b)
    edges[b].append(a)

def solve():
    values = edge_num.values()

    for v, num in edge_num.items():
        if num % 2 == 1:
            return False

    four = []
    for v, num in edge_num.items():
        if num >= 6:
            return True
        if num >= 4:
            four.append(v)

    if len(four) >= 3:
        return True
    if len(four) <= 1:
        return False

    # ????????????????????????
    v0 = four[0]
    v1 = four[1]
    path_num = 0

    def dfs(v, from_v):
        for child in edges[v]:
            if child == from_v:
                continue
            else:
                if child == v1:
                    return 1
                elif child == v0:
                    return 0
                else:
                    return dfs(child, v)

    for child in edges[v0]:
        path_num += dfs(child, v0)

    if path_num == 4:
        return False
    elif path_num == 2:
        return True

if solve():
    print("Yes")
else:
    print("No")